"""Async wrappers for external malware analysis tools."""

import asyncio
import json
import shutil
from typing import List, Dict, Optional
from pathlib import Path


class ToolNotFoundError(Exception):
    """Raised when a required external tool is not available."""
    pass


class ToolExecutionError(Exception):
    """Raised when tool execution fails."""
    pass


async def run_capa_async(file_path: str) -> List[Dict]:
    """
    Run capa (FLARE capability detector) asynchronously.

    Args:
        file_path: Path to the PE file to analyze

    Returns:
        List of capability dictionaries with:
        - namespace: str (e.g., "anti-analysis/anti-debugging")
        - name: str (e.g., "check for debugger")
        - description: str
        - matches: List of address matches

    Raises:
        ToolNotFoundError: If capa is not installed
        ToolExecutionError: If capa execution fails
    """
    # Check if capa is available
    if not shutil.which("capa"):
        raise ToolNotFoundError("capa not found in PATH. Install with: pip install flare-capa")

    # Determine rules path (check local first, then fall back to auto)
    rules_path = Path(__file__).parent.parent / "rules"
    if not rules_path.exists():
        rules_path = "auto"
    else:
        rules_path = str(rules_path)

    # Run capa with JSON output
    try:
        process = await asyncio.create_subprocess_exec(
            "capa",
            "-r",
            rules_path,
            "-s",
            "/dev/null",  # No signatures (use -s /dev/null to bypass)
            "--json",
            file_path,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )

        stdout, stderr = await process.communicate()

        if process.returncode != 0:
            error_msg = stderr.decode('utf-8', errors='ignore')
            raise ToolExecutionError(f"capa failed: {error_msg}")

        # Parse JSON output
        raw_result = json.loads(stdout.decode('utf-8'))

        # Extract capabilities from capa's JSON format
        capabilities = []

        # capa JSON structure: {"rules": {"rule_name": {"meta": {...}, "matches": [...]}}}
        rules = raw_result.get("rules", {})

        for rule_name, rule_data in rules.items():
            meta = rule_data.get("meta", {})
            matches = rule_data.get("matches", [])

            capability = {
                "namespace": meta.get("namespace", "unknown"),
                "name": rule_name,
                "description": meta.get("description", ""),
                "matches": [
                    str(match) for match in matches
                ] if matches else [],
            }
            capabilities.append(capability)

        return capabilities

    except json.JSONDecodeError as e:
        raise ToolExecutionError(f"Failed to parse capa output: {e}")
    except Exception as e:
        raise ToolExecutionError(f"capa execution failed: {e}")


async def run_floss_async(file_path: str) -> List[Dict]:
    """
    Run floss (FLARE obfuscated string solver) asynchronously.

    Args:
        file_path: Path to the PE file to analyze

    Returns:
        List of string finding dictionaries with:
        - string: str (the decoded string)
        - type: str ("static", "decoded", "stack")
        - address: Optional[int] (location in binary)

    Raises:
        ToolNotFoundError: If floss is not installed
        ToolExecutionError: If floss execution fails
    """
    # Check if floss is available
    if not shutil.which("floss"):
        raise ToolNotFoundError("floss not found in PATH. Install with: pip install flare-floss")

    # Run floss with JSON output
    try:
        process = await asyncio.create_subprocess_exec(
            "floss",
            "--only", "decoded", "stack",  # Focus on decoded and stack strings
            "-j",  # JSON output (short flag)
            file_path,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )

        stdout, stderr = await process.communicate()

        if process.returncode != 0:
            error_msg = stderr.decode('utf-8', errors='ignore')
            raise ToolExecutionError(f"floss failed: {error_msg}")

        # Parse JSON output
        raw_result = json.loads(stdout.decode('utf-8'))

        # Extract strings from floss's JSON format
        findings = []

        # floss JSON structure varies by version, handle common formats
        # Decoded strings (most interesting for malware)
        decoded_strings = raw_result.get("decoded_strings", [])
        for item in decoded_strings:
            findings.append({
                "string": item.get("string", ""),
                "type": "decoded",
                "address": item.get("address"),
            })

        # Stack strings (also interesting)
        stack_strings = raw_result.get("stack_strings", [])
        for item in stack_strings:
            findings.append({
                "string": item.get("string", ""),
                "type": "stack",
                "address": item.get("address"),
            })

        return findings

    except json.JSONDecodeError as e:
        raise ToolExecutionError(f"Failed to parse floss output: {e}")
    except Exception as e:
        raise ToolExecutionError(f"floss execution failed: {e}")


def check_tools_available() -> Dict[str, bool]:
    """
    Check which external tools are available.

    Returns:
        Dictionary mapping tool names to availability (True/False)
    """
    return {
        "capa": shutil.which("capa") is not None,
        "floss": shutil.which("floss") is not None,
    }
